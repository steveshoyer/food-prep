# -*- coding: utf-8 -*-
"""
MET CS 644 - Steve Shoyer - April 30, 2020
Project 2 - Food Preparation System (v7)

This project uses a natural language front end to receive a food order, then
uses a PDDL planner back end to determine the process for preparing the meal.

Dialogflow - www.dialogflow.com
Solver - solver.planning.domains/solve

Input files used are:
    food-prep-7.pddl - Domain description for food preparation
    order-7.template.pddl - Template file for problem description
    order-7-generated.pddl' - Problem description generated by the program
    food-database-7.json - JSON representation of ingredient inventory database

"""

"""
    Dialogflow requirements:
    dialogflow        0.5.1
    google-api-core   1.4.1
"""
import os
import dialogflow
from google.api_core.exceptions import InvalidArgument
from google.protobuf.json_format import MessageToDict
import requests
import json

# files to be used    
domain_file = 'food-prep-7.pddl'
problem_template = 'order-7.template.pddl'
problem_file = 'order-7-generated.pddl'
database_file = "food-database-7.json"


os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = 'private_key.json'

DIALOGFLOW_PROJECT_ID = 'food-prep-vtxuyr'
DIALOGFLOW_LANGUAGE_CODE = 'en'
SESSION_ID = 'me'

# initialize a dictionary to hold food orders
order_list = list()
prompt= 'Welcome to the food preparation system - \nHow can I help you?'
order_verified = False  # flag to make sure that we verify the order
# The basic loop: get input, send it to Dialog flow, figure out what to do 
while not (order_verified):  # repeat the process until we have a verified order

    # get user input for a food order
    while True:
        text_to_be_analyzed = str(input(prompt + ' '))
        if (len(text_to_be_analyzed)>0):  # we got some input, so continue
            break
        prompt = "Please type something: "  # prompt for some input and try again

    # send the input string to Dialogflow, receive analysis of the input
    session_client = dialogflow.SessionsClient()
    session = session_client.session_path(DIALOGFLOW_PROJECT_ID, SESSION_ID)
    text_input = dialogflow.types.TextInput(text=text_to_be_analyzed, language_code=DIALOGFLOW_LANGUAGE_CODE)
    query_input = dialogflow.types.QueryInput(text=text_input)
    try:
        response = session_client.detect_intent(session=session, query_input=query_input)
    except InvalidArgument:
        raise

    # see if it was a food order, process it if it was
    intent = response.query_result.intent.display_name
    default_num = 1  # this is a default number for food orders
    if intent == 'order food':
        query_result = MessageToDict(response.query_result)  # get the results from Dialogflow
        num_food = len(query_result['parameters']['food-choice'])
        num_numbers = len(query_result['parameters']['number'])
        for i in range (num_food):  # process each order in this request
            # figure out how many items to order
            if (num_numbers >= num_food) or (i < num_numbers):  # there are at least as many numbers as food items, or we're not at the end of the numbers yet
                num_for_order = int(float(query_result['parameters']['number'][i]))
                default_num = num_for_order  # remember this number, use it if there's no quantity for later items
            else:
                num_for_order = default_num  # no number, so use the last one
            order_list.append([query_result['parameters']['food-choice'][i], num_for_order])
        prompt = response.query_result.fulfillment_text  # pick up the next prompt

    elif intent == 'exit':
        # verify the order before moving on to the next stage
        print("\nHere's what I've got:")
        print(order_list)
        if (str(input("Did I get that right? (y,n)  ")) in ('Y','y')):
            print("Great - one moment while I plan your meal")
            order_verified = True  # got the order correct, time to plan
        else:  # mistake in the order, so start again
            prompt = "Sorry about that - let's start over\nWhat can I get for you?"
            order_list = list()  # clear out the order
    
    else:  # not a food order, so reply with a message from Dialogflow
        prompt = response.query_result.fulfillment_text  # pick up the next prompt

# OK, the order is ready to be planned - iterate through the menu items and plan each one    

print("\nPlans for preparing your order:")

# read the database of inventory items into a dictionary
with open(database_file, 'r') as f:
    food_object_database = json.load(f)
all_ingred_list = list(food_object_database.keys())
all_ingred_str= ' '.join([str(elem) for elem in all_ingred_list])

# set up a list to use for updating the inventory after planning the meals
inventory_items = list()  
        
# process each item in the order
for meal in order_list:
    cook_me = meal[0]  # get the name of the meal
    print("\n" + cook_me + ":\n")

    # Read in the problem template file
    with open(problem_template, 'r') as file :
      prob_file = file.read()
    
    # set up the string of available ingredients
    ingred_list = [item for item in all_ingred_list if food_object_database[item]['quantity'] > 0]
    ingred_str= ' '.join([str(elem) for elem in ingred_list])
    # set up string for available ingredients
    on_hand_list = ['(on-hand {0} inv)'.format(item) for item in ingred_list]
    on_hand_str = '\n    '.join([str(elem) for elem in on_hand_list])
    # generate string of all processes for all available ingredients
    process_list = list()  
    for x in ingred_list:
        for y in food_object_database[x]['processes']:
            process_list.append('({0} {1})'.format(y,x))
    process_str = '\n    '.join([str(elem) for elem in process_list])

    # Replace the target strings in the problem definition
    prob_file = prob_file.replace('COOK-ME', cook_me)
    prob_file = prob_file.replace('INVENTORY-LIST', all_ingred_str)
    prob_file = prob_file.replace('ON-HAND-LIST', on_hand_str)
    prob_file = prob_file.replace('PROCESS-LIST', process_str)
    
    # Write the generated problem file
    with open(problem_file, 'w') as file:
      file.write(prob_file)
    
    # format the request to send to Dialogflow
    data = {'domain': open(domain_file, 'r').read(),
            'problem': open(problem_file, 'r').read()}
    
    resp = requests.post('http://solver.planning.domains/solve',
                         verify=False, json=data).json()
    
    inventory_items = list()  # set up a list to use for updating the inventory
    try:
        # first, identify and display the plan
        plan_string = '\n'.join([act['name'] for act in resp['result']['plan']])
        print(plan_string)
        # next, update the inventory if any ingredients were used
        plan_list = plan_string.split('\n')  # get list of each step
        for step in plan_list:
            step_words = step.split(' ')  # get each word in the step
            if step_words[-1] == 'inv)':  # this step used an inventory item
                inventory_items.append(step_words[-2])  # add the ingredient to be removed from inventory
        print('\nThis dish used: ' + ', '.join(str(x) for x in inventory_items))
        for ingred in inventory_items:
            food_object_database[ingred]['quantity'] -= 1  # decrease the number left in inventory
    except:  # the list comprehension above will throw an exception if there's no plan
        print("Sorry; I'm not able to make " + cook_me)

# OK, all done with the planning - generate a shopping list to bring the
# inventory up to the reorder level
shopping_list = [[item, (food_object_database[item]['reorder'] - food_object_database[item]['quantity'])] \
                 for item in all_ingred_list \
                     if (food_object_database[item]['reorder'] - food_object_database[item]['quantity'] > 0)]

if shopping_list:
    print("\nShopping list to replenish ingredients:")
    for item in shopping_list:
        print('   {0} : {1}'.format(item[0], item[1]))